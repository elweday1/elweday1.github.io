---
// UNDER CONSTRUCTION, WILL BE HIDDEN
import { slugifyStr } from "@utils/slugify";
import { getCollection } from "astro:content";
import Datetime from "./Datetime.astro";
import { Icon } from "astro-icon";
import removeMd from "remove-markdown"; 


const posts = await getCollection("blog");
const projects = await getCollection("projects"); 
const entries = [...posts, ...projects].map((entry)=>{
  return {...entry, blob:  [entry.data.title, entry.data.description, removeMd(entry.body)].join("\n")}
});


---

    <label  class="relative block">
      <span class="absolute inset-y-0 left-0 flex items-center pl-2 opacity-75">
        <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <path d="M19.023 16.977a35.13 35.13 0 0 1-1.367-1.384c-.372-.378-.596-.653-.596-.653l-2.8-1.337A6.962 6.962 0 0 0 16 9c0-3.859-3.14-7-7-7S2 5.141 2 9s3.14 7 7 7c1.763 0 3.37-.66 4.603-1.739l1.337 2.8s.275.224.653.596c.387.363.896.854 1.384 1.367l1.358 1.392.604.646 2.121-2.121-.646-.604c-.379-.372-.885-.866-1.391-1.36zM9 14c-2.757 0-5-2.243-5-5s2.243-5 5-5 5 2.243 5 5-2.243 5-5 5z"></path>
        </svg>
      </span>
      <input
        id="search-input"
        class=" px-[0.75rem] py-[0.32rem] indent-8 w-full justify-self-center bg-skin-card/30 rounded-lg text-md  block border border-skin-fill 
      border-opacity-40 bg-skin-fill 
       placeholder:italic placeholder:text-opacity-75 
      focus:border-skin-accent focus:outline-none"
        placeholder="Search for anything..."
        type="text"
        name="search"
        onchange=""
        autocomplete="off"
        autofocus
      />
    </label>

    <p id="number-of-results" class="text-skin-base/70 p-3 ">Search results</p>
    <ul id="search-results"  class="grid grid-cols-1 gap-4 p-4 overflow-y-auto">
      {
        entries.map(({slug, data, collection, blob}) => {
            const href = `/${collection}/${slug}`
            return (
                <a data-blob={blob} data-title={slugifyStr(data.title)} href={href} class="bg-skin-fill rounded-lg p-3 flex flex-col">
                  <div class="w-full flex flex-row justify-between">
                    <Datetime relative size="sm" datetime={data.dateTime} endDate={collection == "blog" ? undefined:data.endDate} class="text-skin-base/70  inline-block scale-75 origin-left" />
                    <div class="w-fit flex gap-1  place-items-center justify-end ">
                      <Icon class="text-skin-base/70 size-4" name={collection == "blog" ? "ant-design:read-outlined" : "ic:baseline-code" }/> 
                      <span class="text-skin-base/70 scale-90">{collection == "blog" ? "Post" : "Project"}</span>
                    </div>
                  </div>
                    <span transition:name={slug}  class="text-skin-accent">{data.title}</span>
                    <div class="inline">
                      <span data-part="pre" class="" /><span data-part="match" class="text-skin-accent" /><span data-part="post" class="" />
                    </div>
                </a>
            )
        }
    )}
    </ul>
  <script lang="ts">

  const WINDOW_SIZE = 800; 
  const SENTENCES = 2; 

  function sentence(s, first) {
      const delimiters = /[.!?,;\n]/g; 
      const delimiterPositions = [...s.matchAll(delimiters)].map(match => match.index);
      if (first) {
          const firstDelimiterPosition = delimiterPositions.at(SENTENCES);
          return firstDelimiterPosition !== undefined ? s.slice(0, firstDelimiterPosition + 1) : s;
      } else {
          const lastDelimiterPosition = delimiterPositions.at(-SENTENCES);
          return lastDelimiterPosition !== undefined ? s.slice(lastDelimiterPosition + 1) : s;
      }
    }

  function getMatch(blob, query) {
        const start = blob.toLowerCase().indexOf(query.toLowerCase())
        const end = start + query.length
        if (start !== -1) {

          const pre = sentence(blob.slice(start - WINDOW_SIZE, start), false)
          const match = blob.slice(start, end)
          const post = sentence(blob.slice(end, end + WINDOW_SIZE), true)
            return [pre, match, post]
        }

    }

    function updateList(q) {
      const url = new URL(window.location) ;
      url.searchParams?.set('q', q);
      if (!q) url.searchParams.delete("q");
      window.history.pushState(null, '', url.toString());
      let hiddenCount = 0;
      let resultCount = 0;
      const parentElement = document.getElementById("search-results");
      Array.from(parentElement.children).forEach((child) => {
        if (!child || !child.classList ){
          return
        }
        
        const blob = child.getAttribute("data-blob");
        const match = getMatch(blob, q);
        if (match) {
          resultCount += 1;
          child.classList.remove("hidden");
          child.querySelector(`[data-part='pre']`).innerText = match.match[0];
          child.querySelector(`[data-part='match']`).innerText = match.match[1];
          child.querySelector(`[data-part='post']`).innerText = match.match[2];
        }
        else {
          child.classList.add("hidden");
          hiddenCount += 1;
        }
      })

      const nMatches = document.getElementById("number-of-results");
      if (hiddenCount !== resultCount)
      {
        nMatches.innerText = `Found ${resultCount} ${resultCount === 1 ? "result" : "results" } for "${q}"`
      }
      else {
        if (q === "")
        {
          nMatches.innerText = `Start Typing to get results!`
        } else {
          nMatches.innerText = `No results found for "${q}" `
        }
      }
    }

    
    document.addEventListener("DOMContentLoaded", ()=>{
      const url = new URL(window.location) ;
      const q = url.searchParams.get('q');
      const input = document.querySelector("#search-input");
      input.focus();
      if (q) {
        document.querySelector("#search-input").value = q;      
        updateList(q)
      }
      input.addEventListener("input", (e) =>{ 
        updateList(e.target.value)
      });

    });


</script>
 